<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand & Finger Tracker (Webcam)</title>
  <style>
    :root { --bg:#0b0f14; --fg:#e9eef5; --muted:#94a3b8; --acc:#7c3aed; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    header { padding:16px 20px; border-bottom:1px solid #1f2937; display:flex; align-items:center; gap:16px; flex-wrap:wrap; }
    h1 { font-size:16px; margin:0; letter-spacing:.2px; color:#e5e7eb; }
    .badge { padding:4px 8px; background:#111827; border:1px solid #1f2937; border-radius:999px; color:#cbd5e1; }
    main { display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px; height:calc(100vh - 58px); }
    #stage { position:relative; border-radius:16px; overflow:hidden; border:1px solid #1f2937; background:#000; }
    #video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); /* mirror */ }
    #canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; transform: scaleX(-1); }
    #sidebar { border:1px solid #1f2937; border-radius:16px; padding:14px; background:#0b1220; display:flex; flex-direction:column; gap:12px; }
    .row { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .controls { gap:12px; }
    label { color:#cbd5e1; font-weight:600; font-size:12px; }
    select, button, input[type="checkbox"] { all:unset; }
    select, .btn { padding:10px 12px; background:#0f172a; border:1px solid #1f2937; color:#e5e7eb; border-radius:10px; cursor:pointer; }
    .btn[disabled] { opacity:.5; cursor:not-allowed; }
    .stats { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .stat { padding:10px; background:#0f172a; border:1px solid #1f2937; border-radius:10px; }
    .stat b { display:block; font-size:18px; margin-bottom:2px; }
    .muted { color:var(--muted); font-size:12px; }
    .note { font-size:12px; color:#9ca3af; }
    footer { position:absolute; right:12px; bottom:12px; background:rgba(10,14,20,.55); border:1px solid #1f2937; backdrop-filter: blur(6px); border-radius:10px; padding:8px 10px; }
    a { color:#c084fc; text-decoration:none; }
    details { border:1px solid #1f2937; border-radius:10px; padding:8px 10px; background:#0f172a; }
    summary { cursor:pointer; color:#cbd5e1; }
    .tests { font-size:12px; color:#cbd5e1; }
    .pass { color:#34d399; }
    .fail { color:#f87171; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    body.mobile { font-size:15px; }
    body.mobile header { padding:12px 16px; flex-direction:column; align-items:flex-start; gap:8px; }
    body.mobile main { grid-template-columns:1fr; grid-template-rows:auto auto; height:auto; padding:12px; gap:12px; }
    body.mobile #stage { min-height:55vh; }
    body.mobile #sidebar { order:2; padding:12px; gap:12px; }
    body.mobile #sidebar .controls { flex-direction:column; align-items:stretch; }
    body.mobile #sidebar .controls .btn { width:100%; text-align:center; }
    body.mobile #sidebar .field { flex-direction:column; align-items:stretch; }
    body.mobile #sidebar .field select { width:100%; }
    body.mobile select, body.mobile .btn { padding:12px 14px; font-size:15px; }
    body.mobile label { font-size:13px; }
    body.mobile footer#hud { left:12px; right:12px; bottom:12px; text-align:center; }
    body.mobile .stats { grid-template-columns:repeat(2, minmax(0, 1fr)); }
    body.mobile details { padding:10px 12px; }
    body.mobile summary { font-size:14px; }

    .mobile-model-hint { display:none; }
    body.mobile .mobile-model-hint { display:block; }
  </style>
</head>
<body>
  <header>
    <h1>üñêÔ∏è Hand & Finger Tracker</h1>
    <span class="badge">MediaPipe HandLandmarker ‚Ä¢ 2 hands ‚Ä¢ 21 keypoints</span>
  </header>
  <main>
    <section id="stage">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
      <footer id="hud">Loading model options‚Ä¶</footer>
    </section>
    <aside id="sidebar">
      <div class="row controls">
        <button id="startBtn" class="btn">Start camera</button>
        <button id="stopBtn" class="btn" disabled>Stop</button>
      </div>
      <div class="row field">
        <label for="cameraSel">Camera</label>
        <select id="cameraSel"></select>
      </div>
      <div class="row field">
        <label for="modelSel">Model</label>
        <select id="modelSel"></select>
      </div>
      <p class="note mobile-model-hint">We start with <strong>Balanced performance (float16)</strong> on mobile because it‚Äôs slightly faster to download and run on slower devices, though precision is reduced. Switch to <strong>High accuracy (float32)</strong> for the cleanest tracking when your hardware can handle it.</p>
      <div class="row">
        <label class="row" style="gap:6px;cursor:pointer"><input type="checkbox" id="mirrorToggle" checked> Mirror view</label>
      </div>
      <div class="row toggles">
        <label class="row" style="gap:6px;cursor:pointer"><input type="checkbox" id="boxesToggle" checked> Show boxes</label>
        <label class="row" style="gap:6px;cursor:pointer"><input type="checkbox" id="skeletonToggle" checked> Show skeleton</label>
        <label class="row" style="gap:6px;cursor:pointer"><input type="checkbox" id="labelsToggle" checked> Show labels</label>
        <label class="row" style="gap:6px;cursor:pointer"><input type="checkbox" id="fingerDrawingToggle"> Finger drawing</label>
        <label class="row" style="gap:6px;cursor:pointer"><input type="checkbox" id="laserToggle"> Laser mode</label>
      </div>

      <details>
        <summary>Advanced thresholds</summary>
        <div class="row" style="flex-direction:column; align-items:stretch; gap:10px; margin-top:10px;">
          <label>
            Detection confidence <span class="muted mono" id="detectionConfVal">0.70</span>
            <input type="range" id="detectionConf" min="0" max="1" step="0.05" value="0.7">
          </label>
          <label>
            Presence confidence <span class="muted mono" id="presenceConfVal">0.65</span>
            <input type="range" id="presenceConf" min="0" max="1" step="0.05" value="0.65">
          </label>
          <label>
            Tracking confidence <span class="muted mono" id="trackingConfVal">0.65</span>
            <input type="range" id="trackingConf" min="0" max="1" step="0.05" value="0.65">
          </label>
          <p class="note">Higher thresholds improve accuracy, while lower values can improve speed on slower devices.</p>
        </div>
      </details>

      <div class="stats">
        <div class="stat"><b id="fps">0</b><span class="muted">FPS</span></div>
        <div class="stat"><b id="handsCount">0</b><span class="muted">Hands</span></div>
        <div class="stat" style="grid-column:1 / -1"><b id="gesture">‚Äî</b><span class="muted">Gesture (simple heuristics)</span></div>
      </div>

      <details>
        <summary>Diagnostics & Tests</summary>
        <div class="tests">
          <p>Use these smoke tests if something breaks. Results show here and in the console.</p>
          <div class="row controls">
            <button id="runTests" class="btn">Run tests</button>
            <button id="clearTests" class="btn">Clear</button>
            <button id="clearDrawings" class="btn">Clear drawings</button>
          </div>
          <ul id="testResults"></ul>
        </div>
      </details>

      <div class="note">
        Tip: If the camera doesn‚Äôt start from a file URL, run a local server (e.g. <code>python -m http.server</code>) or use a Live Server extension. Works on desktop & most phones.<br><br>
        Model picker: <strong>High accuracy (float32)</strong> offers the most precise landmarks but needs more GPU/CPU and bandwidth. Switch to <strong>Balanced performance (float16)</strong> if you need faster loads or lower memory use at the cost of slight accuracy.
      </div>
    </aside>
  </main>

  <script type="module">
    // ‚úÖ FIX: Import all exports instead of a non-existent default export
    // The previous line `import vision from ...` throws: 
    // "SyntaxError: Importing binding name 'default' cannot be resolved by star export entries."
    import * as vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";
    const { HandLandmarker, FilesetResolver, DrawingUtils } = vision;

    // --- DOM hooks
    const body = document.body;
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const cameraSel = document.getElementById('cameraSel');

    const fpsEl = document.getElementById('fps');
    const handsCountEl = document.getElementById('handsCount');
    const gestureEl = document.getElementById('gesture');

    const modelSel = document.getElementById('modelSel');
    const mirrorToggle = document.getElementById('mirrorToggle');
    const boxesToggle = document.getElementById('boxesToggle');
    const skeletonToggle = document.getElementById('skeletonToggle');
    const labelsToggle = document.getElementById('labelsToggle');
    const fingerDrawingToggle = document.getElementById('fingerDrawingToggle');
    const laserToggle = document.getElementById('laserToggle');
    const detectionConf = document.getElementById('detectionConf');
    const presenceConf = document.getElementById('presenceConf');
    const trackingConf = document.getElementById('trackingConf');
    const detectionConfVal = document.getElementById('detectionConfVal');
    const presenceConfVal = document.getElementById('presenceConfVal');
    const trackingConfVal = document.getElementById('trackingConfVal');

    const runTestsBtn = document.getElementById('runTests');
    const clearTestsBtn = document.getElementById('clearTests');
    const clearDrawingsBtn = document.getElementById('clearDrawings');
    const testResultsEl = document.getElementById('testResults');

    // --- Responsive detection
    const mobileMediaQuery = window.matchMedia('(max-width: 768px)');
    const mobileUserAgent = /Mobi|Android|iPhone|iPad|iPod/i;

    function isMobileEnvironment() {
      return mobileUserAgent.test(navigator.userAgent || '') || mobileMediaQuery.matches;
    }

    function applyMobileClass() {
      body.classList.toggle('mobile', isMobileEnvironment());
    }

    applyMobileClass();
    if (typeof mobileMediaQuery.addEventListener === 'function') {
      mobileMediaQuery.addEventListener('change', applyMobileClass);
    } else if (typeof mobileMediaQuery.addListener === 'function') {
      mobileMediaQuery.addListener(applyMobileClass);
    }
    window.addEventListener('resize', applyMobileClass);
    window.addEventListener('orientationchange', applyMobileClass);

    // --- State
    const MODEL_OPTIONS = {
      float32: {
        label: 'High accuracy (float32)',
        path: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float32/1/hand_landmarker.task',
        description: 'Best landmark precision, heavier on memory/compute.'
      },
      float16: {
        label: 'Balanced performance (float16)',
        path: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
        description: 'Smaller model with slightly lower landmark fidelity.'
      }
    };

    let stream = null;
    let running = false;
    let detector = null;
    let drawingUtils = null;
    let frameCounter = 0;
    let lastFpsUpdate = performance.now();
    let filesetPromise = null;
    const fingerDrawings = new Map();
    const FINGER_MOVE_THRESHOLD = 0.01;
    const LASER_COLORS = {
      Left: '#38bdf8',
      Right: '#f472b6'
    };
    const LASER_FALLBACK = ['#facc15', '#a855f7', '#f97316'];

    function resetFpsCounters() {
      frameCounter = 0;
      lastFpsUpdate = performance.now();
    }

    function populateModelOptions() {
      modelSel.innerHTML = '';
      Object.entries(MODEL_OPTIONS).forEach(([value, meta]) => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = meta.label;
        modelSel.appendChild(opt);
      });
      const defaultModel = isMobileEnvironment() ? 'float16' : 'float32';
      modelSel.value = defaultModel;
      modelSel.title = MODEL_OPTIONS[modelSel.value]?.description || '';
    }

    populateModelOptions();
    hud.textContent = `Loaded ${MODEL_OPTIONS[modelSel.value]?.label || 'model'}${body.classList.contains('mobile') ? ' for quicker loads on mobile.' : '.'}`;

    // --- Camera helpers
    async function listCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      cameraSel.innerHTML = '';
      cams.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i+1}`;
        cameraSel.appendChild(opt);
      });
      if (!cams.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No cameras found';
        cameraSel.appendChild(opt);
      }
      return cams;
    }

    function getVideoConstraints(deviceId) {
      const resolution = body.classList.contains('mobile')
        ? { width: { ideal: 640 }, height: { ideal: 480 } }
        : { width: { ideal: 1280 }, height: { ideal: 720 } };

      const facingMode = (!body.classList.contains('mobile') || mirrorToggle.checked)
        ? 'user'
        : { ideal: 'environment' };

      return {
        ...(deviceId ? { deviceId: { exact: deviceId } } : {}),
        ...resolution,
        facingMode
      };
    }

    function stopMediaStream(mediaStream) {
      if (!mediaStream) return;
      mediaStream.getTracks().forEach(track => track.stop());
    }

    async function startCamera() {
      const previousStream = stream;
      let newStream = null;
      try {
        const deviceId = cameraSel.value || undefined;
        newStream = await navigator.mediaDevices.getUserMedia({
          video: getVideoConstraints(deviceId),
          audio: false
        });

        video.srcObject = newStream;
        stream = newStream;
        await video.play();
        resizeCanvas();
        resetFingerDrawings();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        resetFpsCounters();

        const activeDeviceId = stream?.getVideoTracks?.()?.[0]?.getSettings?.()?.deviceId || deviceId || '';
        try {
          const cams = await listCameras();
          if (activeDeviceId && Array.isArray(cams) && cams.some(cam => cam.deviceId === activeDeviceId)) {
            cameraSel.value = activeDeviceId;
          }
        } catch (listErr) {
          console.warn('Unable to refresh camera list after starting stream', listErr);
        }

        hud.textContent = 'Camera running';

        if (previousStream && previousStream !== stream) {
          stopMediaStream(previousStream);
        }
      } catch (err) {
        if (newStream) {
          stopMediaStream(newStream);
        }

        stream = previousStream;
        if (previousStream) {
          video.srcObject = previousStream;
          await video.play().catch(() => {});
        } else {
          video.pause();
          video.srcObject = null;
        }

        hud.textContent = 'Camera error: ' + (err?.message || 'Unknown error');
        throw err;
      }
    }

    function stopCamera() {
      if (stream) {
        stopMediaStream(stream);
        stream = null;
      }
      video.pause();
      video.srcObject = null;
      hud.textContent = 'Camera stopped';
      resetFingerDrawings();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      resetFpsCounters();
      fpsEl.textContent = '0';
      handsCountEl.textContent = '0';
      gestureEl.textContent = '‚Äî';
    }

    function resizeCanvas() {
      const { videoWidth: w, videoHeight: h } = video;
      if (!w || !h) return;
      canvas.width = w;
      canvas.height = h;
      // Set a stable font for label measurements
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    }

    video.addEventListener('loadedmetadata', resizeCanvas);
    window.addEventListener('resize', resizeCanvas);

    // --- Hand detector setup (MediaPipe Tasks)
    async function initDetector(modelKey = modelSel.value) {
      const selected = MODEL_OPTIONS[modelKey] || MODEL_OPTIONS.float32;
      if (!filesetPromise) {
        filesetPromise = FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );
      }
      const files = await filesetPromise;
      if (detector) {
        detector.close();
        detector = null;
      }

      const delegates = ['GPU', 'CPU'];
      let lastError = null;
      for (const delegate of delegates) {
        try {
          detector = await HandLandmarker.createFromOptions(files, {
            baseOptions: {
              modelAssetPath: selected.path,
              delegate
            },
            numHands: 2,
            runningMode: 'VIDEO',
            minHandDetectionConfidence: parseFloat(detectionConf.value),
            minHandPresenceConfidence: parseFloat(presenceConf.value),
            minTrackingConfidence: parseFloat(trackingConf.value)
          });
          drawingUtils = new DrawingUtils(ctx);
          const delegateLabel = delegate === 'CPU' ? ' (CPU fallback)' : '';
          hud.textContent = `Loaded ${selected.label}${delegateLabel}`;
          return detector;
        } catch (err) {
          console.warn(`HandLandmarker init failed for ${delegate} delegate`, err);
          lastError = err;
        }
      }

      hud.textContent = `Model load error: ${lastError?.message || 'Unknown error'}`;
      throw lastError;
    }

    function updateThresholdDisplays() {
      detectionConfVal.textContent = Number(detectionConf.value).toFixed(2);
      presenceConfVal.textContent = Number(presenceConf.value).toFixed(2);
      trackingConfVal.textContent = Number(trackingConf.value).toFixed(2);
    }

    function applyDetectorThresholds() {
      updateThresholdDisplays();
      if (detector) {
        detector.setOptions({
          minHandDetectionConfidence: parseFloat(detectionConf.value),
          minHandPresenceConfidence: parseFloat(presenceConf.value),
          minTrackingConfidence: parseFloat(trackingConf.value)
        });
      }
    }

    // --- Simple gesture heuristics
    function distance(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function fingersUp(landmarks) {
      // Index, middle, ring, pinky: tip vs pip (y lower = up because y is top->down)
      const tips = [8,12,16,20];
      const pips = [6,10,14,18];
      let count = 0;
      for (let i=0;i<4;i++) if (landmarks[tips[i]].y < landmarks[pips[i]].y) count++;
      // Thumb (rough): use distance change as a loose proxy
      const thumbUp = distance(landmarks[4], landmarks[2]) > 0.06;
      return count + (thumbUp ? 1 : 0);
    }

    function gestureFromLandmarks(landmarks) {
      const pinch = distance(landmarks[4], landmarks[8]);
      if (pinch < 0.045) return 'ü§è Pinch';
      const f = fingersUp(landmarks);
      if (f === 0) return '‚úä Fist';
      if (f === 1) return 'üëç/‚òùÔ∏è One';
      if (f === 2) return '‚úåÔ∏è Two';
      if (f === 3) return 'üëå/Three';
      if (f === 4) return 'üññ/Four';
      if (f === 5) return 'üñêÔ∏è Open Palm';
      return '‚Äî';
    }

    function drawBoxForLandmarks(landmarks) {
      let minX=1, minY=1, maxX=0, maxY=0;
      for (const p of landmarks) {
        if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x; if (p.y > maxY) maxY = p.y;
      }
      const x = minX * canvas.width;
      const y = minY * canvas.height;
      const w = (maxX - minX) * canvas.width;
      const h = (maxY - minY) * canvas.height;
      ctx.strokeStyle = '#7c3aed';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);
    }

    function ensureFingerBuffer(handed) {
      if (!fingerDrawings.has(handed)) {
        fingerDrawings.set(handed, { strokes: [], activeStroke: null, lastPoint: null });
      }
      return fingerDrawings.get(handed);
    }

    function deactivateFingerStroke(buffer) {
      if (!buffer) return;
      buffer.activeStroke = null;
      buffer.lastPoint = null;
    }

    function resetFingerDrawings() {
      fingerDrawings.clear();
    }

    function addFingerPoint(buffer, point) {
      if (!buffer) return;
      if (!buffer.activeStroke) {
        buffer.activeStroke = [point];
        buffer.strokes.push(buffer.activeStroke);
        buffer.lastPoint = point;
        return;
      }
      const last = buffer.lastPoint;
      if (!last || Math.hypot(point.x - last.x, point.y - last.y) >= FINGER_MOVE_THRESHOLD) {
        buffer.activeStroke.push(point);
        buffer.lastPoint = point;
      }
    }

    function renderFingerPaths() {
      if (!fingerDrawingToggle?.checked || !fingerDrawings.size) return;
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(124, 58, 237, 0.85)';
      ctx.fillStyle = ctx.strokeStyle;
      fingerDrawings.forEach(buffer => {
        buffer.strokes.forEach(stroke => {
          if (!Array.isArray(stroke) || stroke.length === 0) return;
          if (stroke.length === 1) {
            const p = stroke[0];
            ctx.beginPath();
            ctx.arc(p.x * canvas.width, p.y * canvas.height, 3, 0, Math.PI * 2);
            ctx.fill();
            return;
          }
          ctx.beginPath();
          stroke.forEach((pt, idx) => {
            const x = pt.x * canvas.width;
            const y = pt.y * canvas.height;
            if (idx === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.stroke();
        });
      });
      ctx.restore();
    }

    function parseHexColor(hex) {
      if (typeof hex !== 'string') {
        return { r: 124, g: 58, b: 237 };
      }
      let str = hex.replace('#', '');
      if (str.length === 3) {
        str = str.split('').map(ch => ch + ch).join('');
      }
      const int = parseInt(str.slice(0, 6), 16);
      if (Number.isNaN(int)) {
        return { r: 124, g: 58, b: 237 };
      }
      return {
        r: (int >> 16) & 255,
        g: (int >> 8) & 255,
        b: int & 255
      };
    }

    function drawLaserBeams(beams) {
      if (!laserToggle?.checked || !Array.isArray(beams) || beams.length === 0) return;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineCap = 'round';
      const baseWidth = Math.max(canvas.width, canvas.height);
      beams.forEach(({ start, end, color }) => {
        if (!start || !end) return;
        const sx = start.x * canvas.width;
        const sy = start.y * canvas.height;
        const ex = end.x * canvas.width;
        const ey = end.y * canvas.height;
        const { r, g, b } = parseHexColor(color);
        const gradient = ctx.createLinearGradient(sx, sy, ex, ey);
        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0)`);
        gradient.addColorStop(0.25, `rgba(${r}, ${g}, ${b}, 0.25)`);
        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.95)`);
        ctx.lineWidth = Math.max(2, baseWidth * 0.01);
        ctx.strokeStyle = gradient;
        ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.7)`;
        ctx.shadowBlur = Math.max(10, baseWidth * 0.03);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();

        const radius = Math.max(8, baseWidth * 0.02);
        const tipGlow = ctx.createRadialGradient(ex, ey, 0, ex, ey, radius);
        tipGlow.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.95)`);
        tipGlow.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        ctx.fillStyle = tipGlow;
        ctx.beginPath();
        ctx.arc(ex, ey, radius, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }

    function getLaserColor(handed, index) {
      if (handed && LASER_COLORS[handed]) return LASER_COLORS[handed];
      return LASER_FALLBACK[index % LASER_FALLBACK.length];
    }

    // --- Main loop
    function loop() {
      if (!running) return;
      if (!detector || video.readyState < 2) {
        requestAnimationFrame(loop);
        return;
      }

      const now = performance.now();
      let results = {};
      try {
        results = detector.detectForVideo(video, now) || {};
      } catch (err) {
        console.error('Hand detection error', err);
        hud.textContent = 'Detection error: ' + (err?.message || 'Unknown error');
        if (running) requestAnimationFrame(loop);
        return;
      }
      const hands = Array.isArray(results.landmarks) ? results.landmarks : [];

      const seenHands = new Set();
      const gesturesInfo = hands.map((lm, i) => {
        const handed = results.handednesses?.[i]?.[0]?.categoryName || `Hand ${i + 1}`;
        seenHands.add(handed);
        const gestureLabel = gestureFromLandmarks(lm);
        if (fingerDrawingToggle?.checked) {
          const shouldDraw = gestureLabel.includes('Open Palm') || gestureLabel.includes('Pinch');
          const buffer = ensureFingerBuffer(handed);
          if (shouldDraw) {
            const tip = lm[8];
            if (tip) {
              addFingerPoint(buffer, { x: tip.x, y: tip.y });
            }
          } else {
            deactivateFingerStroke(buffer);
          }
        }
        return { gesture: gestureLabel, handed };
      });

      if (fingerDrawingToggle?.checked) {
        fingerDrawings.forEach((buffer, handed) => {
          if (!seenHands.has(handed)) {
            deactivateFingerStroke(buffer);
          }
        });
      }

      // Clear & draw overlays
      ctx.clearRect(0,0,canvas.width, canvas.height);
      renderFingerPaths();

      const laserBeams = [];
      if (laserToggle?.checked) {
        hands.forEach((lm, i) => {
          const info = gesturesInfo[i];
          if (!info || !info.gesture?.includes('Open Palm')) return;
          const start = lm?.[0];
          const end = lm?.[12];
          if (!start || !end) return;
          laserBeams.push({
            start,
            end,
            color: getLaserColor(info.handed, i)
          });
        });
      }
      let gestureText = '‚Äî';
      if (hands.length === 1) {
        gestureText = gesturesInfo[0]?.gesture || '‚Äî';
      } else if (hands.length > 1) {
        gestureText = 'Multiple';
      }
      handsCountEl.textContent = String(hands.length);

      hands.forEach((lm, i) => {
        if (skeletonToggle.checked) {
          drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
          drawingUtils.drawLandmarks(lm, { lineWidth: 1, radius: 2 });
        }
        if (boxesToggle.checked) drawBoxForLandmarks(lm);

        const info = gesturesInfo[i] || {};
        const g = info.gesture || gestureFromLandmarks(lm);

        if (labelsToggle.checked) {
          const handed = info.handed || results.handednesses?.[i]?.[0]?.categoryName || '';
          const label = `${handed} ${g}`.trim();
          // place label near wrist (0)
          const p = lm[0];
          ctx.fillStyle = 'rgba(12, 18, 32, .75)';
          ctx.strokeStyle = '#1f2937';
          const x = p.x * canvas.width, y = p.y * canvas.height - 12;
          const textW = ctx.measureText(label).width + 12;
          ctx.beginPath(); ctx.roundRect(x-4, y-18, textW, 20, 6); ctx.fill(); ctx.stroke();
          ctx.fillStyle = '#e5e7eb';
          ctx.fillText(label, x+2, y-3);
        }
      });

      drawLaserBeams(laserBeams);

      // FPS calc
      frameCounter++;
      if (now - lastFpsUpdate > 500) {
        const fps = Math.round((frameCounter * 1000) / (now - lastFpsUpdate));
        fpsEl.textContent = String(fps);
        lastFpsUpdate = now;
        frameCounter = 0;
      }

      gestureEl.textContent = gestureText;
      if (running) requestAnimationFrame(loop);
    }

    // --- UI wiring
    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      stopBtn.disabled = true;
      hud.textContent = 'Starting camera‚Ä¶';
      try {
        await startCamera();

        hud.textContent = 'Initializing model‚Ä¶';
        const selectedModel = modelSel.value;
        let fallbackNotice = '';
        try {
          await initDetector(selectedModel);
        } catch (primaryErr) {
          console.error('Primary model init failed', primaryErr);
          if (selectedModel !== 'float16') {
            const reason = primaryErr?.message || 'Unknown error';
            modelSel.value = 'float16';
            await initDetector('float16');
            fallbackNotice = `Model "${selectedModel}" failed (${reason}). Switched to float16.`;
          } else {
            throw primaryErr;
          }
        }

        if (fallbackNotice) {
          hud.textContent = fallbackNotice;
        }

        stopBtn.disabled = false;
        running = true;
        requestAnimationFrame(loop);
      } catch (e) {
        console.error(e);
        const errorMsg = 'Init error: ' + (e?.message || 'Unknown error');
        hud.textContent = errorMsg;
        running = false;
        if (detector) {
          detector.close();
          detector = null;
        }
        stopCamera();
        hud.textContent = errorMsg;
        stopBtn.disabled = true;
        startBtn.disabled = false;
      }
    });

    stopBtn.addEventListener('click', () => {
      running = false;
      if (detector) {
        detector.close();
        detector = null;
      }
      stopCamera();
      stopBtn.disabled = true;
      startBtn.disabled = false;
    });

    cameraSel.addEventListener('change', async () => {
      if (!stream) return;
      const previousDeviceId = stream?.getVideoTracks?.()?.[0]?.getSettings?.()?.deviceId || '';
      try {
        await startCamera();
      } catch (e) {
        console.error(e);
        if (previousDeviceId) {
          const option = Array.from(cameraSel.options).find(opt => opt.value === previousDeviceId);
          if (option) {
            cameraSel.value = previousDeviceId;
          }
        }
        if (previousDeviceId) {
          hud.textContent += ' Restored previous camera.';
        }
      }
    });

    modelSel.addEventListener('change', async () => {
      modelSel.title = MODEL_OPTIONS[modelSel.value]?.description || '';
      hud.textContent = 'Switching model‚Ä¶';
      try {
        await initDetector(modelSel.value);
        hud.textContent = `Loaded ${MODEL_OPTIONS[modelSel.value]?.label || 'model'}`;
      } catch (e) {
        console.error(e);
        hud.textContent = 'Model load error: ' + e.message;
      }
    });

    mirrorToggle.addEventListener('change', () => {
      const val = mirrorToggle.checked ? 'scaleX(-1)' : 'none';
      document.getElementById('video').style.transform = val;
      document.getElementById('canvas').style.transform = val;
    });

    fingerDrawingToggle?.addEventListener('change', () => {
      if (!fingerDrawingToggle.checked) {
        resetFingerDrawings();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    });

    [detectionConf, presenceConf, trackingConf].forEach(input => {
      input.addEventListener('input', applyDetectorThresholds);
    });

    updateThresholdDisplays();

    // polyfill for CanvasRenderingContext2D.roundRect on older browsers
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
        if (w<2*r) r=w/2; if (h<2*r) r=h/2;
        this.beginPath();
        this.moveTo(x+r,y);
        this.arcTo(x+w,y,x+w,y+h,r);
        this.arcTo(x+w,y+h,x,y+h,r);
        this.arcTo(x,y+h,x,y,r);
        this.arcTo(x,y,x+w,y,r);
        this.closePath();
        return this;
      }
    }

    // --- Diagnostics / Tests ---
    function addResult(ok, msg) {
      const li = document.createElement('li');
      li.className = ok ? 'pass' : 'fail';
      li.textContent = (ok ? '‚úî ' : '‚úñ ') + msg;
      testResultsEl.appendChild(li);
      (ok ? console.log : console.error)(msg);
    }

    async function runTests() {
      testResultsEl.innerHTML = '';

      // Test 1: Module exports exist
      try {
        addResult(typeof HandLandmarker === 'function', 'HandLandmarker export is available');
        addResult(typeof FilesetResolver === 'object' || typeof FilesetResolver === 'function', 'FilesetResolver export is available');
        addResult(typeof DrawingUtils === 'function', 'DrawingUtils export is available');
      } catch (e) {
        addResult(false, 'Module export check threw: ' + e.message);
      }

      // Test 2: Initialize detector (WASM + model load)
      try {
        if (!detector) {
          await initDetector();
        }
        addResult(!!detector, 'HandLandmarker created');
        addResult(!!drawingUtils, 'DrawingUtils initialized');
      } catch (e) {
        addResult(false, 'Detector init failed: ' + e.message);
      }

      // Test 3: detectForVideo is callable (smoke test without requiring frames)
      try {
        addResult(typeof detector.detectForVideo === 'function', 'detectForVideo function exists');
      } catch (e) {
        addResult(false, 'detectForVideo missing: ' + e.message);
      }

      // Test 4: UI elements present
      addResult(!!document.getElementById('startBtn'), 'Start button present');
      addResult(!!document.getElementById('canvas'), 'Canvas present');
      addResult(!!document.getElementById('video'), 'Video element present');
    }

    runTestsBtn?.addEventListener('click', runTests);
    clearTestsBtn?.addEventListener('click', () => testResultsEl.innerHTML = '');
    clearDrawingsBtn?.addEventListener('click', () => {
      resetFingerDrawings();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // Pre-populate camera list on load (requires permission on some browsers)
    if (navigator.mediaDevices?.enumerateDevices) {
      listCameras().catch(()=>{});
    }

    // Expose a tiny testing handle for external scripts or console
    window.__HANDTRACK_TEST__ = { runTests };
  </script>
</body>
</html>
